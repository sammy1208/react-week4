---
title: 【佐久侑】自食色果
author: 空
summary: |
  哎激情速打点宵夜，开个假车，没写完但凑合发吧。有点微醺语言很混乱。
  > - 少量dirty talk
  > - 无意义
  > - ooc
  > - 文本未校对，请见谅
---


“臣臣，臣臣”

“......”

“臣臣？你睡了吗”

半晌，背后没传来任何动静，宫侑叹了口气。伸手不见五指的漆黑里，有一双眼睛缓缓睁开，额前那两颗鲜明的痣，似乎还带着点不耐烦。

“说”

“臣臣没睡还这么久不理我，你不爱我了吗？”

老实说，佐久很吃他这一套，明明是该头疼的事情，可他不得不说——宫侑明知他会烦还不厌其烦的吵他这个认知让他神经兴奋，且屡试不爽。

跟宫侑在一起的日子他都快感觉自己不像自己了。

可偏偏他还享受这种叨扰，也享受这只臭狐狸勾引他。

“臣臣，我们好像很久没做爱了”

他突然揪住佐久的衣领翻身坐起来，跨上佐久的腰，居高临下地望着他的圣臣，性暗示意味十足地勾舔着嘴角。

这突如其来的举动惊得佐久腹背瞬间收紧，下意识扶住他的腰，手也护在背后随时防备他掉下去——尽管这是做爱时养成的习惯，总之佐久还是没适应他这想一出是一出的毛病。

“你想做？”

佐久确保这调皮的狐狸在他身上坐稳后还是不放心，干脆支起腿让他靠着，然后才空出手摸手机，摁亮屏幕举到坐在他身上的人面前。

“现在？”

上面显示现在是凌晨三点二十七分。

“臣臣不行吗？”

又开始玩文字游戏了。佐久方才紧绷的身子渐渐放松下来，他懒散地靠在床头，盯着宫侑那张好看的脸半天没发作，平时要将他拆吃入腹的赤裸目光也迟迟不肯出现，不知道是不是灯光昏暗的原因，实际上也根本没开灯，两人对峙良久，还是宫侑先按耐不住用他饱满的翘臀蹭那个能让他死去活来，此刻却在沉寂的家伙。

他实在太小瞧佐久早圣臣了。

佳人在怀，坐怀不乱是他的强项。

不过仅限于他们俩之间——因为他压根儿不会允许除了这只黄毛狐狸以外的人...包括东西，这么霸道地坐在他身上。

扶在宫侑腰间的那只手穿进衣摆往上攀了攀，佐久仔细感受着他的二传手娇嫩紧致的胸肌，指尖所到之处无不泛起轻微的颤栗。

他太过了解这幅身体，以至于只是稍加柔弄就引得宫侑舒服地摇晃自己的腰肢，淹没在布料下的指尖在那团蜜褐色周围轻点、打圈，直到作祟的狐狸发出舒服的谓叹，此时恰好压在乳尖上的指腹爱抚戛然而止。

宫侑时常会怀疑自己是否被什么魅魔附体了，才会为佐久如此痴迷，就比如现在。

谁知道那伴生皮似的黑口罩下有一张性感到操蛋的脸。

只有我见过他这样。

宫侑餍足地想。

“继续啊...臣臣......呜...！别玩我了”

刚开始宫侑还稍微能跟他过几招，股间的缝隙隔着薄薄一层布料摩挲挑逗那半勃的物什，慢慢地，他觉察到自己的内裤被浸湿，却不止是小佐顶部渗出来的清液，他惊恐地发现是自己的后面淌出些可耻的粘稠液体来。

这实在太怪了。他羞得不敢挪开脸上的小臂，生怕佐久发现什么端倪，但他愈是感觉到黏在他胸前的视线，下体就愈发不可控制地发洪。

“手，拿开”

试图这样就瞒过佐久的话，他就不是佐久了。他早在小狐狸反常的第一秒就发现了。

......

食指月牙修剪得干净利落，和这双手主人此刻粗暴色情的举止完全不符，佐久发了狠地抠弄根本不可能存在于宫侑身上的乳孔，好似不抠出个能渗奶的洞眼来不罢休，该死的另一只手还色情地托在宫侑的囊袋下抛晃，好几次擦过精水流淌的铃口都不肯去抠挖两下给他个痛快，下流、卑鄙还无耻！乘人之危却又饱含着这哑巴恋人的爱意......

种种擦边球的快感让宫侑几乎要抓狂。这种累积起来是宫侑最招架不住的，他被折磨得四肢绵软、花枝乱颤，后仰的腰身与蜜臀几近折叠...他趴在佐久身上，两具年轻精壮的身体紧紧相贴，连宫侑在高潮边缘传来的紧绷他的腹部都感知得一清二楚。

佐久明白怎么让他的小狐狸崩溃。

“藏什么，嗯？你又不是第一次流这么多水了”

宫侑慌不择路的去捂佐久那张没落在身上也让他烧红耳根的嘴。

“叫我什么”

这是佐久询问的第三遍，在此之前宫侑的回答一直是臣臣，他不是最喜欢喊他老公调戏他了吗？也不知道这是抖M的把戏还是别的什么。天邪鬼？可能吧，宫侑实在有这方面的潜能。

“呃啊...！哈...吸吸它、吧嗯嗯呃....哈啊疼？！...圣臣啊......给我吸吸好不好...！”

佐久立刻收了手，宫侑好不容易得了个喘息的机会，却像离了水的鱼儿瘙痒难耐，嘴里不知哼唧着什么。

“在叫什么，宫”

佐久终于舍得坐起来，结实的臂肌发力暴起了一瞬，将捞起宫侑把他放成舒服的姿势——每次侑情到深处脱力时他都是这么做的，可惜极爱这幕的宫侑错过了，他曾锐评过佐久扣球时整条手臂呈现的青筋：不得不说我愿意为此短暂的变成基佬。

事实上，他也的确这么做了，还是永久性的。

当时他嘴上说着是客观评价，其实是在黑狼队训练时咂摸昨晚被顶到失声尖叫着射尿的滋味，爽归爽，该报复臣臣的还是要提上日程。

还没等来报复的机会，就给自己先搭进去了，甚至在这种时候自我高潮，于是他生理意义上也同时高潮了。

......

佐久拿着抽纸替宫侑掖额角的汗，倒是难得没有第一时间清理射在自己胸膛的精液，好吧其实是因为宫侑压着了。

“现在想起来圣臣是谁了吗”

他咬着宫侑耳垂的软肉问，贝齿间叼着一小块狐狸耳的软肉，吐息间的热气激得宫侑直接瘫软倒在他怀里。

他喘着气，迷恋这属于佐久的味道。

溃不成军。

“老...老公、臣臣是”

佐久拨开粘连在他额前的发丝，

“刚才要老公吸哪里”

“都要嘛......”

“要什么”

讲道理，就调情这方面而言，宫侑也不是吃素的，今晚让佐久得逞太多次也该找点场子回来了。此时，狐狸的手悄悄挪到那团硬得发疼的阴茎后面。

酝酿这么久，现在时机才正好。

“老公，帮我吸吸乳头吧”

......

“尾巴收起来，我要进去了”

佐久今晚被那尾巴勾得火大，每次出来都打他措手不及。

“我...明明就、没有尾巴...”

宫侑面红耳赤，眼神涣散还不忘思考自己是不是有尾巴这件事，今晚这句话出现的频率似乎太高了，是不是真的如小臣所说他是只狐狸？但为什么被榨干的是他，臣臣的声音叫他小狐狸好色情哦...尽管听上去感觉像是在说他是个不知廉耻的小荡妇......

不知过了多久，耷拉下去的阴茎射得一会儿一阵的抽动，而且射出来的东西已经不是简单的稀薄了，他他妈应该是射空了。

再射下去又他妈只剩尿了。

“臣臣啊...撞、啊啊得屁股...好痛、不做了呃呃嗯...好不好啊....我错了嗯嗯！....”

要是明天新闻头条是MSBY队内矛盾，二传手在主攻的床上精尽人亡，宫治一定会笑烂他的......他已经被操得意识模糊了。

而佐久还在后面不知疲倦地打桩，他下意识收紧后穴想帮他快射出来快点结束这场灭顶的灾难——今晚已经超出宫侑对于性爱带来的快感程度认知了。

只见一阵天旋地转，他的下颌被佐久捏在手心里，仿佛随时都能捏碎。

啪！

宫侑眼前闪过白光，本来就混沌的大脑也卡机了。

他屁股上结结实实挨了一巴掌，后知后觉的灼烧感短暂地拉回宫的听力，然后紧接着又死机了。

“骚狐狸，自己掰开”

— Fin. —


很好 — 我把整個流程從頭到尾拆成 概念 + 必要套件 + 前端實作範例 (TypeScript + React + Vite)，並說明每個步驟為什麼要這樣做、常見陷阱與進階選項。你可以直接把範例貼到專案改用（或按需簡化）。

概念總覽

YAML Frontmatter（放在 Markdown 檔最上方的 --- 區塊）用來存放 metadata（title、author、chapters 列表、summary...），方便前端先取得章節清單等結構化資訊。

gray-matter 是一個在 JavaScript/TypeScript 中解析 YAML frontmatter 的工具：它把 frontmatter 解析成 data（物件），剩下的正文放在 content（純 Markdown 字串）。

react-markdown 負責把 Markdown content 轉成 React 元素。你可以透過 components 覆寫特定 tag（例如 h1、h2）來加上 id 或其他行為（這對章節跳轉很重要）。

為了安全若要解析 Markdown 裡的 raw HTML，要同時使用 rehype-raw + rehype-sanitize（或避免 raw HTML）。

章節跳轉（點選 Header 的章節）可用 document.getElementById(id).scrollIntoView({behavior:'smooth'})，或改用 router hash /#id。

安裝需要的套件

在 Vite (React + TS) 專案下安裝：

npm install react-markdown remark-gfm gray-matter
# 若需要處理 raw HTML（小心 XSS）：
npm install rehype-raw rehype-sanitize
# 若想自動為 headings 產生 slug id：
npm install remark-slug rehype-autolink-headings

Markdown 範例（含 frontmatter）

把檔案放 public/novels/galaxy_dream.md（或你想放的路徑）：

---
id: "galaxy_dream"
title: "星河夢境"
author: "蘇念"
summary: |
  夢境與現實交錯的奇幻冒險。
chapters:
  - id: "c1"
    title: "第一章 星河初現"
  - id: "c2"
    title: "第二章 虛空之門"
  - id: "c3"
    title: "第三章 夢中之城"
---

# 第一章 星河初現

夜空下，少女望著遠方的流星，彷彿看見了命運的微光...

# 第二章 虛空之門

風聲低鳴，門扉緩緩開啟...

# 第三章 夢中之城

城市漂浮於雲層之上...


重點：chapters 在 frontmatter 內給了章節 ID 與標題（這能讓你在 Header 用已知 ID 跳轉）。同時 Markdown 裡也要有對應的標題，或你可以在渲染時把 chapters 與 Markdown 標題對應起來。

TypeScript 型別（放 src/types/novel.ts）
export interface ChapterMeta {
  id: string;
  title: string;
}

export interface NovelMeta {
  id: string;
  title?: string;
  author?: string;
  summary?: string;
  chapters?: ChapterMeta[];
  file?: string; // md 路徑
}

實作範例：NovelPage.tsx（載入 .md, 解析 frontmatter, 渲染 Markdown，並為 headings 加 id）

完整功能：

fetch JSON 或 md metadata（這範例直接 fetch md），

用 gray-matter 解析 frontmatter（拿到 meta.chapters）並放到 store/Context（供 Header 使用），

用 react-markdown 渲染 content，在 heading 渲染器加 id（以 meta.chapters 的 id 對應 title），

支援點選 Header chapter 時 scrollIntoView()。

// src/pages/NovelPage.tsx
import React, { useEffect, useState, useMemo } from "react";
import { useParams } from "react-router-dom";
import matter from "gray-matter";
import ReactMarkdown from "react-markdown";
import remarkGfm from "remark-gfm";
import { NovelMeta, ChapterMeta } from "../types/novel";
import { useNovelStore } from "../store/useNovelStore"; // 或 Context

// 若需要 raw HTML（慎用）
// import rehypeRaw from "rehype-raw";
// import rehypeSanitize from "rehype-sanitize";

export default function NovelPage() {
  const { id } = useParams<{ id: string }>();
  const [meta, setMeta] = useState<NovelMeta | null>(null);
  const [content, setContent] = useState<string>("");
  const setChapters = useNovelStore((s) => s.setChapters); // 假設你用 Zustand

  useEffect(() => {
    if (!id) return;
    const load = async () => {
      const res = await fetch(`/novels/${id}.md`);
      if (!res.ok) throw new Error("找不到小說檔案");
      const text = await res.text();
      const parsed = matter(text); // { data, content }
      const data = parsed.data as NovelMeta;
      setMeta({ ...data, id }); // 儲存 meta
      setContent(parsed.content);
      // 如果 frontmatter 有 chapters，丟到全域 store（Header 會用）
      if (Array.isArray(data.chapters)) {
        setChapters(data.chapters as ChapterMeta[]);
      } else {
        // 若沒有 chapters，你也可以自動偵測（下一段示範）
        setChapters([]);
      }
    };

    load().catch((e) => {
      console.error(e);
      // 顯示錯誤 UI 或 fallback
    });
  }, [id, setChapters]);

  // 建立一個 mapping: title -> id（若 frontmatter 有 chapters）
  const titleToIdMap = useMemo(() => {
    const map = new Map<string, string>();
    if (meta?.chapters) {
      meta.chapters.forEach((c) => map.set(c.title.trim(), c.id));
    }
    return map;
  }, [meta]);

  // react-markdown components override：為 h1/h2 加 id
  const components = {
    h1: ({ node, children }: any) => {
      // children 可能是 ['第一章 星河初現'] 或一個 React node
      const text = String(children?.[0] ?? "").trim();
      // 優先用 frontmatter 提供的 id，否則產生 slug (簡單替代)
      const anchorId = titleToIdMap.get(text) ?? text.replace(/\s+/g, "-");
      return (
        <h1 id={anchorId} className="chapter-title">
          {children}
        </h1>
      );
    },
    // 若你有 h2/h3 也可以同理處理
  };

  return (
    <div className="book-main container">
      <h2 className="book-title">{meta?.title}</h2>
      <p className="author">{meta?.author}</p>

      <div className="description">
        <p className="description-title">Summary:</p>
        <p className="description-p">{meta?.summary}</p>
      </div>

      <div className="article">
        <ReactMarkdown
          remarkPlugins={[remarkGfm]}
          // rehypePlugins={[rehypeRaw, rehypeSanitize]} // only if you need raw HTML and sanitize
          components={components}
        >
          {content}
        </ReactMarkdown>
      </div>
    </div>
  );
}


重點說明：

matter(text) 把 frontmatter 解析為 data（metadata）與 content（Markdown 內文）。

titleToIdMap 幫你把 frontmatter 中的 chapters（title/id）對應到 Markdown heading。這讓你在 header 中可以直接用 frontmatter 的 id 做跳轉（不必把 heading text 當 id）。

components.h1 為每個 # 標題插入 id，讓 document.getElementById(id) 可找到目標。

Header（漢堡選單）：拿 chapters 並跳轉

假設你把章節放到全域 store（useNovelStore），Header 可以這樣做：

// src/components/Header.tsx
import React from "react";
import { useNovelStore } from "../store/useNovelStore";

export default function Header() {
  const chapters = useNovelStore((s) => s.chapters);

  const handleJump = (id: string) => {
    const el = document.getElementById(id);
    if (el) {
      el.scrollIntoView({ behavior: "smooth" });
    } else {
      // 若找不到，可能需要路由導向再跳轉
      console.warn("找不到章節節點", id);
    }
  };

  return (
    <header className="header">
      <button className="menu-btn">☰</button>
      <nav className="chapter-menu">
        {chapters.map((c) => (
          <button key={c.id} onClick={() => handleJump(c.id)}>
            {c.title}
          </button>
        ))}
      </nav>
    </header>
  );
}


小提醒：若 Header 在全站共用，但章節只在 NovelPage 載入後才存在，Header 需要能感知到章節變更（所以用全域 store 很合適）。

如果你要自動偵測 Markdown 標題（當 frontmatter 沒提供 chapters）

有時候你不想手動在 frontmatter 列章節，你可以從 content 用正則或 matchAll 自動抓出 # 標題，例子：

// 在載入 content 後
const headingMatches = Array.from(content.matchAll(/^#{1,3}\s+(.+)$/gm));
const autoChapters = headingMatches.map((m, i) => ({ id: `c${i+1}`, title: m[1].trim() }));
setChapters(autoChapters);


優點：免維護章節 list；缺點：需保證 Markdown 內標題寫法一致（例如都用 # 作章節）。

進階：自動產生 slug id 的套件（選用）

如果不想自己實作 slug，可以使用 remark-slug + rehype-autolink-headings：

import remarkGfm from "remark-gfm";
import remarkSlug from "remark-slug";
import rehypeAutolink from "rehype-autolink-headings";

<ReactMarkdown
  remarkPlugins={[remarkGfm, remarkSlug]}
  rehypePlugins={[[rehypeAutolink, { behavior: "append" }]]}
>
  {content}
</ReactMarkdown>


remark-slug 會自動為 headings 加上 id；rehype-autolink-headings 會自動在標題中加入可點擊的連結符號。

注意：若你在 Markdown 中允許 raw HTML，需要同時使用 rehype-raw 與 rehype-sanitize 做 XSS 防護。

常見陷阱 & 注意事項

frontmatter 與 heading 文本不一致：若 frontmatter 的 chapters[i].title 與 Markdown heading 文字不完全匹配，titleToIdMap.get(text) 可能找不到 id。解法：用 slug 比對（把 heading slug 與 chapter.title slug 比對），或只靠 frontmatter id，不比對文字。

Header 跳轉找不到元素：若 Header 先渲染、Markdown 還沒載入，點擊時找不到元素。解法：等 chapters 設定後才顯示章節選單，或在點擊時檢查是否在當前路由上，若不在則先 navigate 再 scroll。

rehype-raw 有 XSS 風險：避免直接渲染未消毒的 raw HTML；使用 rehype-sanitize 或不要用 rehype-raw。

路由與 hash：你可以用 navigate('/novel/galaxy_dream#c2')，或直接 document.getElementById('c2').scrollIntoView()。hash 的好處是可分享 URL，且瀏覽器會在載入頁面後自動捲到 hash（但若內容是動態載入，可能需要程式處理）。

TypeScript：res.json() 的 any：res.json() 回傳 any，最好用 guard 或轉換型別（如我範例把 parsed.data cast 為 NovelMeta）。

給你的一個完整工作流程建議（步驟）

Markdown 檔加上 frontmatter（包含 chapters 欄位）。

在 NovelPage: fetch md → matter() → setMeta && setContent → setChapters(meta.chapters)。

用 react-markdown 渲染 content，components 或 remark-slug 加入 heading id（以 frontmatter id 對應或用 slug）。

Header 從 store 取得 chapters，點擊用 scrollIntoView 或 navigate 帶 hash。

若要分享 URL，使用 route + hash（需在 NovelPage 載入後檢查 location.hash 並 scroll）。

如果你要，我可以：

幫你把上面範例改成完整的 TypeScript + Zustand store + Header + NovelPage 可執行程式碼檔案（直接貼到你的專案），或

幫你寫一個「當前章節自動高亮（scroll spy）」的範例（會用 IntersectionObserver），或

幫你處理「Header 點章節但不在該小說頁時先 navigate 再自動捲動到章節」的流程細節。

你想先看哪一個完整實作？